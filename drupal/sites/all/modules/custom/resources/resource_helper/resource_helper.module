<?php

function users_owner($uid) {
    global $user;
    return $uid == $user->uid;
}

function shares_accessible() {
    global $user;

    // lets get all the groups first
    $sql = "SELECT shares.*
            FROM shares, members
            WHERE members.user_id = :user_id
            AND shares.group_id = members.group_id";
    $results = db_query($sql, array(
        "user_id"  => $user->uid
    ));

    $ids = array_keys($results->fetchAllAssoc('id'));

    return $ids;
}
function shares_is_accessible($share_id) {
    $ids = shares_accessible();
    return in_array($share_id, $ids);
}
/**
 * Takes an array of share ids, and returns a subset of that array
 * with only accessible share ids
 *
 * @param $ids
 * @return array
 */
function shares_filter_accessible($ids) {
    if(isset($ids)) {
        if(!is_array($ids)) {
            $ids = array($ids);
        }
        // It is set, so we need to filter with it
        return array_intersect($ids, shares_accessible());

    } else {
        // nothing, filter to the max set
        return shares_accessible();
    }
}

function posts_accessible() {
    global $user;
    // lets get all the groups first
    $sql = "SELECT posts.id
            FROM posts, shares, members
            WHERE members.user_id = :user_id
            AND shares.group_id = members.group_id,
            AND posts.share_id = shares.id";
    $results = db_query($sql, array(
        "user_id"  => $user->uid
    ));
    $ids = array_keys($results->fetchAllAssoc('id'));
    return $ids;
}
function posts_is_accessible($activity_id) {
    $ids = posts_accessible();
    return in_array($activity_id, $ids);
}
function posts_filter_accessible($ids) {
    if(isset($ids)) {
        if(!is_array($ids)) {
            $ids = array($ids);
        }
        // It is set, so we need to filter with it
        return array_intersect($ids, posts_accessible());

    } else {
        // nothing, filter to the max set
        return posts_accessible();
    }
}

function activities_accessible() {
    global $user;
    // lets get all the groups first
    $sql = "SELECT activities.id
            FROM activities, shares, members
            WHERE members.user_id = :user_id
            AND shares.group_id = members.group_id,
            AND activities.share_id = shares.id";
    $results = db_query($sql, array(
        "user_id"  => $user->uid
    ));
    $ids = array_keys($results->fetchAllAssoc('id'));
    return $ids;
}
function activities_is_accessible($activity_id) {
    $ids = activities_accessible();
    return in_array($activity_id, $ids);
}
function activities_filter_accessible($ids) {
    if(isset($ids)) {
        if(!is_array($ids)) {
            $ids = array($ids);
        }
        // It is set, so we need to filter with it
        return array_intersect($ids, activities_accessible());

    } else {
        // nothing, filter to the max set
        return activities_accessible();
    }
}

/**
 * Get all patient ids the current user can access
 * @return array    An array of patient IDs
 */
function patients_accessible() {
    global $user;

    $sql = "SELECT patients.id
            FROM patients
            LEFT JOIN members ON members.user_id = :uid
            LEFT JOIN shares ON shares.group_id = members.group_id
            WHERE patients.id = shares.patient_id
            OR patients.uid = :uid";

    $results = db_query($sql, array(
        "uid"   => $user->uid
    ));

    $ids = array_keys($results->fetchAllAssoc('id'));

    return $ids;
}
function patients_filter_accessible($ids) {
    if(isset($ids)) {
        if(!is_array($ids)) {
            $ids = array($ids);
        }
        // It is set, so we need to filter with it
        return array_intersect($ids, patients_accessible());

    } else {
        // nothing, filter to the max set
        return patients_accessible();
    }
}

/**
 * Checks if a patient is accessible by the current user
 * @param $patient_id
 * @return bool - true if accessible
 */
function patients_is_accessible($patient_id) {
    $ids = patients_accessible();


    return in_array($patient_id, $ids);
}


function resource_helper_index($entity_type, $page, $fields, $parameters, $page_size, $orderByColumn="id", $orderByDirection="ASC") {

    $query = new EntityFieldQuery();

    $query->entityCondition('entity_type', $entity_type);

    foreach($parameters as $parameter => $value) {
        if(is_numeric($value)) {
            $query->propertyCondition($parameter, $value);
        } elseif(is_array($value)) {
            // its an array
            if(count($value)) {
                $query->propertyCondition($parameter, $value, 'IN');
            } else {
                // We are looking for IN 'empty array'
                // so we should always return nothing
                return array();
            }
        } else {
            // its a string, lets do a starts with
            $query->propertyCondition($parameter, $value, 'STARTS_WITH');
        }
    }

    $query->range($page * $page_size, $page_size);
    $query->propertyOrderBy($orderByColumn, $orderByDirection);
    $result = $query->execute();

    if(isset($result[$entity_type])) {
        $ids = array_keys($result[$entity_type]);

        $entity_function = $entity_type . "_load_multiple";

        return call_user_func($entity_function, $ids);
    } else {
        return array();
    }

}


function user_load_small($uid, $reset = FALSE) {
    $users = user_load_multiple_small(array($uid), array(), $reset);
    return reset($users);
}

function user_load_multiple_small($uids = array(), $conditions = array(), $reset = FALSE) {
    $users = entity_load('user', $uids, $conditions, $reset);

    $small_users = array();
    foreach($users as $user) {

        $small_user = new stdClass();
        $small_user->uid = $user->uid;
        $small_user->name = $user->name;
        $small_user->picture = $user->picture;
        if(isset($user->picture->uri)) {
//            $small_user->picture->url = file_create_url($user->picture->uri);
            $small_user->picture->thumb_url = image_style_url('thumbnail', $user->picture->uri);
        }
//        $small_user->mail = $user->mail;
//        $small_user->roles = $user->roles;
//
//        $small_user->created = $user->created;
//        $small_user->access = $user->access;
//        $small_user->login = $user->login;
//        $small_user->status = $user->status;
//        $small_user->timezone = $user->timezone;

        $small_users[] = $small_user;
    }

    return $small_users;
}




